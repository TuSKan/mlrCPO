<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Martin Binder" />

<meta name="date" content="2017-12-26" />

<title>Building Custom CPOs</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Building Custom CPOs</h1>
<h4 class="author"><em>Martin Binder</em></h4>
<h4 class="date"><em>2017-12-26</em></h4>



<div id="cpo-vignette-navigation" class="section level4">
<h4>CPO Vignette Navigation</h4>
<ol style="list-style-type: decimal">
<li><a href="a_1_getting_started.html">First Steps</a> (<a href="z_1_getting_started_terse.html">compact version</a>)</li>
<li><a href="a_2_mlrCPO_core.html">mlrCPO Core</a> (<a href="z_2_mlrCPO_core_terse.html">compact version</a>)</li>
<li><a href="a_3_all_CPOs.html">CPOs Built Into mlrCPO</a> (<a href="z_3_all_CPOs_terse.html">compact version</a>)</li>
<li>Building Custom CPOs (<a href="z_4_custom_CPOs_terse.html">compact version</a>)</li>
</ol>
</div>
<div id="intro" class="section level2">
<h2>Intro</h2>
<p>The <a href="a_3_all_CPOs.html"><code>CPO</code>s built into <code>mlrCPO</code></a> can be used for many different purposes, and can be combined to form even more powerful transformation operations. However, in some cases, it may be necessary to define new “custom” <code>CPO</code>s that perform a certain task; either because a preprocessing method is not (yet) defined as a builtin <code>CPO</code>, or because some operation very specific to the task at hand needs to be performed.</p>
<p>For this purpose, <code>mlrCPO</code> offers a very powerful interface for the creation of new <code>CPO</code>s. The functions and methods described here are also the methods used internally to create <code>mlrCPO</code>’s builtin <code>CPO</code>s. Therefore, to learn the art of defining <code>CPO</code>s, it is also possible to look at the <a href="https://github.com/mlr-org/mlrCPO/tree/master/R"><code>mlrCPO</code> source tree</a> in files starting with “<code>CPO_</code>” for example <code>CPO</code> definitions.</p>
<p>There are three types of <code>CPO</code>: “Feature Operation <code>CPO</code>s” (<a href="#feature-operation-cpos"><strong>FOCPO</strong>s</a>) which are only allowed to change feature columns of incoming data, and which are the most common <code>CPO</code>s; “Target Operation <code>CPO</code>s” (<strong>TOCPO</strong>s) that change only target columns, and “Retrafoless <code>CPO</code>s” (<a href="#retrafoless-cpos"><strong>ROCPO</strong>s</a>) that may add or delete rows to a data set, but only during training. Conceptually, ROCPOs are the simplest <code>CPO</code>s, followed by FOCPOs and the even more complicated TOCPOs. The commonalities of all <code>CPO</code> defining functions will be described first, followed by the different <code>CPO</code> types in order of growing complexity.</p>
</div>
<div id="making-a-cpo" class="section level2">
<h2>Making a CPO</h2>
<p>To create a <code>CPOConstructor</code> that can then be used to create a <code>CPO</code>, a <code>makeCPO*()</code> function needs to be called. There are five functions of this kind, differing by what kind of <code>CPO</code> they create and how much flexibility (at the cost of simplicity) they offer the user:</p>
<table>
<thead>
<tr class="header">
<th align="left"><code>CPO</code> type</th>
<th align="left"><code>makeCPO*()</code> functions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">FOCPO</td>
<td align="left"><code>makeCPO()</code>, <code>makeCPOExtendedTrafo()</code></td>
</tr>
<tr class="even">
<td align="left">TOCPO</td>
<td align="left"><code>makeCPOTargetOp()</code>, <code>makeCPOExtendedTargetOp()</code></td>
</tr>
<tr class="odd">
<td align="left">ROCPO</td>
<td align="left"><code>makeCPORetrafoless()</code></td>
</tr>
</tbody>
</table>
<p>Each of these functions takes a “name” for the new <code>CPO</code>, settings for the parameter set to be used, settings for the format in which the data is supposed to be provided, data property settings, the packages to load, <code>CPO</code> type specific settins, and finally the transformation functions.</p>
<div id="cpo-name" class="section level3">
<h3>CPO name</h3>
<p>Each <code>CPO</code> has a “name” that is used for representation when printing, and as the default prefix for hyperparameters. <code>cpoPca</code>, for example, has the name “<code>pca</code>”:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">!<span class="kw">cpoPca</span>()
<span class="co">#&gt; Trafo chain of 1 cpos:</span>
<span class="co">#&gt; pca(center = TRUE, scale = FALSE)[not exp'd: tol = &lt;NULL&gt;, rank = &lt;NULL&gt;]</span>
<span class="co">#&gt; Operating: feature</span>
<span class="co">#&gt; ParamSet:</span>
<span class="co">#&gt;               Type len   Def Constr Req Tunable Trafo</span>
<span class="co">#&gt; pca.center logical   -  TRUE      -   -    TRUE     -</span>
<span class="co">#&gt; pca.scale  logical   - FALSE      -   -    TRUE     -</span></code></pre></div>
<p>The name is set using the <code>cpo.name</code> parameter of the <code>make*()</code> functions.</p>
</div>
<div id="cpo-parameters" class="section level3">
<h3>CPO parameters</h3>
<p>The <code>ParSet</code> used by the <code>CPO</code> are given as the second <code>par.set</code> parameter. These parameters must be either constructed using <code>makeParamSet()</code> from the <code>ParamHelpers</code> package, or using the <code>pSS()</code> function for a more concise <code>ParSet</code> definition. The given parameters will then be the function parameters of the <code>CPOConstructor</code>, and will by default be exported as hyperparameters (prefixed with the <code>cpo.name</code>).</p>
<p>It is possible to use the default parameter values of the <code>par.set</code> as defaults, or to give a <code>par.vals</code> list of default values. If <code>par.vals</code> is given, the defaults within <code>par.set</code> are completely ignored. Parameters that have a default value are set to this value upon construction if no value is given by the user.</p>
<p>Not all available parameters of a <code>CPO</code> need to be exported as hyperparameters. <em>Which</em> parameters are exported can be set during <code>CPO</code> construction, but the default exported parameters can be set using <code>export.params</code>. This can either be a <code>character</code> vector of the names of parameters to export, or <code>TRUE</code> (default, export all) or <code>FALSE</code> (no export).</p>
</div>
<div id="data-format" class="section level3">
<h3>Data Format</h3>
<p>Different <code>CPO</code> operations may want to operate on the data in different forms: as a <code>Task</code>, as a <code>data.frame</code> with or without the target column, etc. The <code>CPO</code> framework can perform some conversion of data to fit different needs, which is set up by the value of the <code>dataformat</code> parameter, together with <code>dataformat.factor.with.ordered</code>. While <code>dataformat</code> has slightly different effects on different <code>CPO</code> types, typically its values and effects are:</p>
<table style="width:114%;">
<colgroup>
<col width="18%"></col>
<col width="95%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left"><code>dataformat</code></th>
<th align="left">Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>&quot;task&quot;</code></td>
<td align="left">Data is given as a <code>Task</code>; if the data to be transformed is a <code>data.frame</code>, it is converted to a <code>cluster</code> task before handing it to the transformation functions.</td>
</tr>
<tr class="even">
<td align="left"><code>&quot;df.all&quot;</code></td>
<td align="left">Data is given as a <code>data.frame</code>, with the target column included.</td>
</tr>
<tr class="odd">
<td align="left"><code>&quot;df.features&quot;</code></td>
<td align="left">Data is given as a <code>data.frame</code>, the target is given as a separate <code>data.frame</code>.</td>
</tr>
<tr class="even">
<td align="left"><code>&quot;split&quot;</code></td>
<td align="left">Data is given as a named list with slots <code>$numeric</code>, <code>$factor</code>, <code>$ordered</code>, <code>$other</code>, each of which contains a <code>data.frame</code> with the columns of the respective type. If <code>dataformat.factor.with.ordered</code> is <code>TRUE</code>, the <code>$ordered</code> slot is not present, and ordered features are instead given to <code>$factor</code> as well. Features that are not any of these types are given to <code>&quot;other&quot;</code>. The target is given as a separate <code>data.frame</code>.</td>
</tr>
<tr class="odd">
<td align="left"><code>&quot;factor&quot;</code>, <code>&quot;ordered&quot;</code>, <code>&quot;numeric&quot;</code></td>
<td align="left">Only the data from columns of the named type are given to the transformatin functions as a <code>data.frame</code>. The target columns are given as a separate <code>data.frame</code>.</td>
</tr>
</tbody>
</table>
<p>Another parameter influencing the data format is the <code>fix.factors</code> flag which controls whether factor levels of prediction data need to be set to be the same as during training. If it is <code>TRUE</code>, previously unseen factor levels are set to <code>NA</code> during prediction.</p>
</div>
<div id="properties" class="section level3">
<h3>Properties</h3>
<p><code>mlr</code> and <code>mlrCPO</code> make it possible to specify what kind of data a <code>CPO</code> or a <code>Learner</code> can handle. However, since <code>CPO</code>s may change data to be more or less fitting for a certain <code>Learner</code>, a <code>CPO</code> must announce not only what data it can handle, but also how it changes the capabilities of the machine learning pipeline in which it is envolved. During construction, four parameters related to properties can be given.</p>
<p>The <code>properties.data</code> parameter defines what properties of feature data the <code>CPO</code> can handle; it must be a subset of <code>&quot;numerics&quot;</code>, <code>&quot;factors&quot;</code>, <code>&quot;ordered&quot;</code>, and <code>&quot;missings&quot;</code>. Typically, only the <code>&quot;missings&quot;</code> part is interesting since <code>CPO</code>s that only handle a subset of types will usually just ignore columns of other types.</p>
<p>The <code>properties.target</code> parameter defines what <code>Task</code> properties related to the task type and the target column a <code>CPO</code> can handle. It is a subset of <code>&quot;cluster&quot;</code>, <code>&quot;classif&quot;</code>, <code>&quot;multilabel&quot;</code>, <code>&quot;regr&quot;</code>, <code>&quot;surv&quot;</code> (so far defining the task type a <code>CPO</code> can handle), <code>&quot;oneclass&quot;</code>, <code>&quot;twoclass&quot;</code>, <code>&quot;multiclass&quot;</code> (properties specific to <code>classif</code> <code>Task</code>s). Most FOCPOs do not care about the task type, while TOCPOs may only support a single task type.</p>
<p><code>properties.adding</code> lists the properties that a CPO <em>adds</em> to the capabilities of a machine learning pipeline when it is executed before it, while <code>properties.needed</code> lists the properties <em>needed</em> from the following pipeline. <code>cpoDummyEncode</code>, for example, a <code>CPO</code> that converts factors and ordereds to numerics, has <code>properties.adding == c(&quot;factors&quot;, &quot;ordered&quot;)</code> and <code>properties.needed == &quot;numerics&quot;</code>. The many imputation <code>CPO</code>s have <code>properties.adding == &quot;missings&quot;</code>. Usually these are only a subset of the possible <code>properties.data</code> states, but for TOCPOs this may also be any of <code>&quot;oneclass&quot;</code>, <code>&quot;twoclass&quot;</code>, <code>&quot;multiclass&quot;</code>. Note that neither <code>properties.adding</code> nor <code>properties.needed</code> may be any task type, even for TOCPOs that perform task conversion.</p>
<div id="property-checking-and-.sometimes-properties" class="section level4">
<h4>Property Checking and <code>.sometimes</code> Properties</h4>
<p>The <code>CPO</code> framework will check that a <code>CPO</code> only adds and removes the kind of data properties that it declared in <code>properties.adding</code> and <code>properties.needed</code>. It will also check that composition of <code>CPO</code>s, and attachment of <code>CPO</code>s to <code>Learner</code>s, work out. Sometimes, however, it is necessary to treat a <code>CPO</code> like it does a certain manipulation (removing <code>missings</code>, for example) in some cases, while not in others. A <code>CPO</code> that only imputes missings in <em>numeric</em> columns should be treated as <code>properties.adding == &quot;missings&quot;</code> when is is attached to a <code>Learner</code>, and the <code>Learner</code> should gain the <code>&quot;missings&quot;</code> property. However, when data that has missings in its factorial columns is given to this <code>CPO</code>, the <code>CPO</code> framework will complain that the <code>CPO</code> that declared <code>&quot;missings&quot;</code> in <code>properties.adding</code> returned data that still had missing values in it. The solution to this dilemma is to suffix some properties with “<code>.sometimes</code>” when declaring them in <code>properties.adding</code> and <code>properties.needed</code>. When composing <code>CPO</code>s, and when checking data <em>returned</em> by a <code>CPO</code>, the framework will then be as lenient as possible. In the given example, <code>properties.adding == &quot;missings&quot;</code> will be assumed when attaching the <code>CPO</code> to a <code>Learner</code>, while <code>properties.adding == character(0)</code> is assumed when checking the <code>CPO</code>’s output (and missing values that were not imputed are therefore forgiven).</p>
</div>
</div>
<div id="packages" class="section level3">
<h3>Packages</h3>
<p>The single <code>packages</code> parameter can be set to a <code>character</code> vector listing packages necessary for a <code>CPO</code> to work. This is mostly useful when a <code>CPO</code> should be defined as part of a package or script to be distributed. The listed package will <em>not</em> automatically be <em>attached</em>, it will only be <em>loaded</em>. This means that a function exported by a package still needs to be called using <code>::</code>. The benefit of declaring it in <code>packages</code> is that it will be loaded upon <em>construction</em> of a <code>CPO</code>, which means that a user will get immediate feedback about whether the <code>CPO</code> can be used or needs more packages to be installed.</p>
</div>
<div id="transformation-functions" class="section level3">
<h3>Transformation Functions</h3>
<p>The different types of <code>CPO</code>, and the different <code>make*()</code> functions, need different transformation functions to be defined. The principle behind these functions is alwasy the same, however: The <code>CPO</code> framework takes input data, transforms it according to <code>dataformat</code>, checks it according to <code>properties.data</code> and <code>properties.target</code>, and then gives it to one or more user-given transformation function. The transformation function must then usually create a control object containing information about the data to be used later, or transform the incoming data and return the transformation result (or both). The <code>CPO</code> framework then checks the transformed data according to <code>properties.adding</code> and <code>properties.needed</code> and gives it back to the <code>CPO</code> user.</p>
<p>Transformation functions are given to parameters starting with <code>cpo.</code>. They can either be given as functions, or as “<strong>headless</strong>” functions missing the <code>function(...)</code> part. In the latter case, the headless function must be a succession of expressions enclosed in curly braces (<code>{</code>, <code>}</code>) and the necessary function head is added by the <code>CPO</code> framework. The functions often take a subset of <code>data</code>, <code>target</code>, <code>control</code>, or <code>control.invert</code> parameters, in addition to all parameters as given in <code>par.set</code>.</p>
<div id="functional-transformation" class="section level4">
<h4>Functional Transformation</h4>
<p>The communication between transformation functions, e.g. giving the PCA matrix to its retrafo function, usually happens via “control” objects created by these functions and then given as parameter to other functions. In some cases, however, it may be more elegant to create a new function (e.g. a <code>cpo.retrafo</code> function) within another function as a “closure” (in the general, not R specific, sense) with access to all the outer functions variables. The <code>CPO</code> framework makes this possible by allowing a function to be given instead of a “control” object. The function which would usually receive this control object must then be given as <code>NULL</code> in the <code>makeCPO*()</code> call.</p>
</div>
</div>
</div>
<div id="retrafoless-cpos" class="section level2">
<h2>Retrafoless CPOs</h2>
<p>Retrafoless <code>CPO</code>s, or ROCPOs, are conceptually the simplest <code>CPO</code> type, since they do not create <code>CPOTrained</code> objects and therefore only need one transformation function: <code>cpo.trafo</code>. The value of the <code>dataformat</code> parameter may only be either <code>&quot;df.all&quot;</code> or <code>&quot;task&quot;</code>, resulting in either a <code>data.frame</code> (consisting all columns, including the target column) or a <code>Task</code> being given to the <code>cpo.trafo</code> function. <code>cpo.trafo</code> should have the parameters <code>data</code> (receiving the data as either a <code>Task</code> or <code>data.frame</code>), <code>target</code> (receiving the names of target columns in the data), and any parameter as given to <code>par.set</code>. The return value of <code>cpo.trafo</code> must be the transformed data, in the same format (<code>data.frame</code> or <code>Task</code>) as given as input.</p>
<p>Since a ROCPO only transforms incoming data during training, it should not do any transformation of target or feature values that would make it necessary to repeat this action during prediction. It may, for example, be used for subsampling a classification task to balance target classes, but it should not change the levels or values of given data rows.</p>
<p>The following is an example of a simplified version of the <code>cpoSample</code> <code>CPO</code>, which takes one parameter <code>fraction</code> and then subsamples a <code>fraction</code> part of incoming data without replacement:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xmpSample =<span class="st"> </span><span class="kw">makeCPORetrafoless</span>(<span class="st">&quot;exsample&quot;</span>,  <span class="co"># nolint</span>
  <span class="kw">pSS</span>(fraction:<span class="st"> </span>numeric[<span class="dv">0</span>, <span class="dv">1</span>]),
  <span class="dt">dataformat =</span> <span class="st">&quot;df.all&quot;</span>,
  <span class="dt">cpo.trafo =</span> function(data, target, fraction) {
    newsize =<span class="st"> </span><span class="kw">round</span>(<span class="kw">nrow</span>(data) *<span class="st"> </span>fraction)
    row.indices =<span class="st"> </span><span class="kw">sample</span>(<span class="kw">nrow</span>(data), newsize)
    data[row.indices, ]
  })

cpo =<span class="st"> </span><span class="kw">xmpSample</span>(<span class="fl">0.01</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">iris %&gt;&gt;%<span class="st"> </span>cpo
<span class="co">#&gt;     Sepal.Length Sepal.Width Petal.Length Petal.Width   Species</span>
<span class="co">#&gt; 44           5.0         3.5          1.6         0.6    setosa</span>
<span class="co">#&gt; 118          7.7         3.8          6.7         2.2 virginica</span></code></pre></div>
<p>It is possible to give the <code>cpo.trafo</code> as <strong>headless</strong> transformation function by just leaving out the function header. This can save a lot of boilerplate code when there are many parameters present, or when many transformation functions need to be given. The resulting <code>CPO</code> is completely equivalent to the one given above.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xmpSampleHeadless =<span class="st"> </span><span class="kw">makeCPORetrafoless</span>(<span class="st">&quot;exsample&quot;</span>,  <span class="co"># nolint</span>
  <span class="kw">pSS</span>(fraction:<span class="st"> </span>numeric[<span class="dv">0</span>, <span class="dv">1</span>]),
  <span class="dt">dataformat =</span> <span class="st">&quot;df.all&quot;</span>,
  <span class="dt">cpo.trafo =</span> {
    newsize =<span class="st"> </span><span class="kw">round</span>(<span class="kw">nrow</span>(data) *<span class="st"> </span>fraction)
    row.indices =<span class="st"> </span><span class="kw">sample</span>(<span class="kw">nrow</span>(data), newsize)
    data[row.indices, ]
  })</code></pre></div>
</div>
<div id="feature-operation-cpos" class="section level2">
<h2>Feature Operation CPOs</h2>
<p>FOCPOs are created with either the <code>makeCPO()</code> function, or the <code>makeCPOExtendedTrafo()</code> function. The former conceptually separates training from transformation, the latter separates transformation of training data from transformation of prediction data.</p>
<div id="makecpo" class="section level3">
<h3><code>makeCPO()</code></h3>
<p>In principle, a FOCPO needs a function that “trains” a control object depending on the data (<code>cpo.train</code>), and another function that uses this control object, and new data, to perform the preprocessing operation (<code>cpo.retrafo</code>). The <code>cpo.train</code>-function must return a “control” object which contains all information about how to transform a given dataset. <code>cpo.retrafo</code> takes a (potentially new!) dataset <em>and</em> the “control” object returned by <code>cpo.trafo</code>, and transforms the new data according to plan.</p>
<p>In contrast to <code>makeCPORetrafoless()</code>, the <code>dataformat</code> parameter of <code>makeCPO()</code> can take all values described in the section <a href="#data-format">Data Format</a>. The <code>cpo.train</code> function takes the arguments <code>data</code>, <code>target</code>, and any other parameter described in <code>param.set</code>. The <code>data</code> value is the incoming data as a <code>Task</code>, a <code>data.frame</code> with or without the target column, or a list of <code>data.frames</code> of different column types, according to <code>dataformat</code>. The <code>target</code> value is a <code>character</code> vector of target names if <code>dataformat</code> is <code>&quot;task&quot;</code> or <code>&quot;df.all&quot;</code>, or a <code>data.frame</code> of the target columns otherwise.</p>
<p>The <code>cpo.train</code> function’s return value is treated as a <code>control</code> object and given to the <code>cpo.retrafo</code> function. Its parameters are <code>data</code>, <code>control</code>, and any parameters in <code>par.set</code>. The format of the data given to the <code>data</code> parameter is according to <code>dataformat</code>, with the exception that if <code>dataformat</code> is either <code>&quot;task&quot;</code> or <code>&quot;df.all&quot;</code>, it will be treated here as if its value were <code>&quot;df.features&quot;</code>. This is because the <code>cpo.retrafo</code> function is sometimes called with <em>prediction</em> data which does not have any target column at all.</p>
<p>It follows the simplified definition of a <code>CPO</code> that removes the numeric columns of smallest variance, returning a dataset of only <code>n.col</code> numeric columns. The <code>dataformat</code> variable is set to <code>&quot;numeric&quot;</code>, so that only numeric columns are given to the <code>CPO</code>’s transformation functiosn; factorial columns are ignored. In <code>cpo.trafo</code>, calculates the variance of each of the data’s columns, and in <code>cpo.retrafo</code> it subsets the data according to these variances. Since <code>cpo.retrafo</code> may also be called during prediction with new data, the variance must <em>not</em> be calculated in <code>cpo.retrafo</code>–this could lead to <code>cpo.retrafo</code> filtering out different columns from <code>cpo.trafo</code>. This example also prints out which of its functions are being called.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xmpFilterVar =<span class="st"> </span><span class="kw">makeCPO</span>(<span class="st">&quot;exemplvar&quot;</span>,  <span class="co"># nolint</span>
  <span class="kw">pSS</span>(n.col:<span class="st"> </span>integer[<span class="dv">0</span>, ]),
  <span class="dt">dataformat =</span> <span class="st">&quot;numeric&quot;</span>,
  <span class="dt">cpo.train =</span> function(data, target, n.col) {
    <span class="kw">cat</span>(<span class="st">&quot;*** cpo.train ***</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">sapply</span>(data, var, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
  },
  <span class="dt">cpo.retrafo =</span> function(data, control, n.col) {
    <span class="kw">cat</span>(<span class="st">&quot;*** cpo.retrafo ***</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">cat</span>(<span class="st">&quot;Control:</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="kw">print</span>(control)
    <span class="kw">cat</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
    greatest =<span class="st"> </span><span class="kw">order</span>(-control)  <span class="co"># columns, ordered greatest to smallest var</span>
    data[greatest[<span class="kw">seq_len</span>(n.col)]]
  })

cpo =<span class="st"> </span><span class="kw">xmpFilterVar</span>(<span class="dv">2</span>)</code></pre></div>
<p>(Note that the function heads are optional.)</p>
<p>When the <code>CPO</code> is called with a dataset, the <code>cpo.train</code> function is called first, creating the control object which is then given to <code>cpo.retrafo</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">trafd =</span> <span class="kw">head</span>(iris) %&gt;&gt;%<span class="st"> </span>cpo)
<span class="co">#&gt; *** cpo.train ***</span>
<span class="co">#&gt; *** cpo.retrafo ***</span>
<span class="co">#&gt; Control:</span>
<span class="co">#&gt; Sepal.Length  Sepal.Width Petal.Length  Petal.Width </span>
<span class="co">#&gt;  0.083000000  0.117666667  0.019000000  0.006666667</span>
<span class="co">#&gt;   Species Sepal.Width Sepal.Length</span>
<span class="co">#&gt; 1  setosa         3.5          5.1</span>
<span class="co">#&gt; 2  setosa         3.0          4.9</span>
<span class="co">#&gt; 3  setosa         3.2          4.7</span>
<span class="co">#&gt; 4  setosa         3.1          4.6</span>
<span class="co">#&gt; 5  setosa         3.6          5.0</span>
<span class="co">#&gt; 6  setosa         3.9          5.4</span></code></pre></div>
<p>Note that the two columns of the entire <code>iris</code> dataset with the greatest variance are <code>Petal.Length</code> and <code>Sepal.Length</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(iris %&gt;&gt;%<span class="st"> </span>cpo)
<span class="co">#&gt; *** cpo.train ***</span>
<span class="co">#&gt; *** cpo.retrafo ***</span>
<span class="co">#&gt; Control:</span>
<span class="co">#&gt; Sepal.Length  Sepal.Width Petal.Length  Petal.Width </span>
<span class="co">#&gt;    0.6856935    0.1899794    3.1162779    0.5810063</span>
<span class="co">#&gt;   Species Petal.Length Sepal.Length</span>
<span class="co">#&gt; 1  setosa          1.4          5.1</span>
<span class="co">#&gt; 2  setosa          1.4          4.9</span>
<span class="co">#&gt; 3  setosa          1.3          4.7</span>
<span class="co">#&gt; 4  setosa          1.5          4.6</span>
<span class="co">#&gt; 5  setosa          1.4          5.0</span>
<span class="co">#&gt; 6  setosa          1.7          5.4</span></code></pre></div>
<p>However, when applying the <code>retrafo()</code> of <code>trafd</code> to the entire dataset, the same columns are filtered out as they were in the first transformation: <code>Sepal.Width</code> and <code>Sepal.Length</code>. When the <code>retrafo()</code> is used, <code>cpo.train</code> is <em>not</em> called; instead, the <code>control</code> object saved inside the retrafo is used.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(iris %&gt;&gt;%<span class="st"> </span><span class="kw">retrafo</span>(trafd))
<span class="co">#&gt; *** cpo.retrafo ***</span>
<span class="co">#&gt; Control:</span>
<span class="co">#&gt; Sepal.Length  Sepal.Width Petal.Length  Petal.Width </span>
<span class="co">#&gt;  0.083000000  0.117666667  0.019000000  0.006666667</span>
<span class="co">#&gt;   Species Sepal.Width Sepal.Length</span>
<span class="co">#&gt; 1  setosa         3.5          5.1</span>
<span class="co">#&gt; 2  setosa         3.0          4.9</span>
<span class="co">#&gt; 3  setosa         3.2          4.7</span>
<span class="co">#&gt; 4  setosa         3.1          4.6</span>
<span class="co">#&gt; 5  setosa         3.6          5.0</span>
<span class="co">#&gt; 6  setosa         3.9          5.4</span></code></pre></div>
<p>It is also possible to inspect the <code>CPOTrained</code> object to see that the <code>control</code> is there:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getCPOTrainedState</span>(<span class="kw">retrafo</span>(trafd))
<span class="co">#&gt; $n.col</span>
<span class="co">#&gt; [1] 2</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $control</span>
<span class="co">#&gt; Sepal.Length  Sepal.Width Petal.Length  Petal.Width </span>
<span class="co">#&gt;  0.083000000  0.117666667  0.019000000  0.006666667 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $data</span>
<span class="co">#&gt; $data$shapeinfo.input</span>
<span class="co">#&gt; &lt;ShapeInfo (input) Sepal.Length: num, Sepal.Width: num, Petal.Length: num, Petal.Width: num, Species: fac&gt;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $data$shapeinfo.output</span>
<span class="co">#&gt; &lt;ShapeInfo (output)&gt;:</span>
<span class="co">#&gt; numeric:</span>
<span class="co">#&gt; &lt;ShapeInfo Sepal.Width: num, Sepal.Length: num&gt;</span>
<span class="co">#&gt; factor:</span>
<span class="co">#&gt; &lt;ShapeInfo Species: fac&gt;</span>
<span class="co">#&gt; other:</span>
<span class="co">#&gt; &lt;ShapeInfo (empty)&gt;</span></code></pre></div>
<div id="functional-cpo" class="section level4">
<h4>Functional CPO</h4>
<p>Instead of returning the <code>control</code> object, <code>cpo.train</code> may also return the <code>cpo.retrafo</code> <em>function</em>. This may be more succinct to write if there are many little pieces of information from the <code>cpo.train</code> run that the <code>cpo.retrafo</code> function should have access to.</p>
<p>When <code>cpo.retrafo</code> is given functionally, it should be a function with only <em>one</em> parameter: the newly incoming data. It can access the values of the <code>par.set</code> parameters from its encapsulating environment in <code>cpo.train</code>.</p>
<p>Note that the <code>data</code> and <code>target</code> values given to <code>cpo.train</code> are <strong>deleted</strong> after the <code>cpo.train</code> call, so <code>cpo.retrafo</code> does not have access to it. In fact, the <code>CPO</code> framework will give a warning about this.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xmpFilterVarFunc =<span class="st"> </span><span class="kw">makeCPO</span>(<span class="st">&quot;exemplvar.func&quot;</span>,  <span class="co"># nolint</span>
  <span class="kw">pSS</span>(n.col:<span class="st"> </span>integer[<span class="dv">0</span>, ]),
  <span class="dt">dataformat =</span> <span class="st">&quot;numeric&quot;</span>,
  <span class="dt">cpo.retrafo =</span> <span class="ot">NULL</span>,
  <span class="dt">cpo.train =</span> function(data, target, n.col) {
    <span class="kw">cat</span>(<span class="st">&quot;*** cpo.train ***</span><span class="ch">\n</span><span class="st">&quot;</span>)
    ctrl =<span class="st"> </span><span class="kw">sapply</span>(data, var, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
    function(x) {  <span class="co"># the data is given to the only present parameter: 'x'</span>
      <span class="kw">cat</span>(<span class="st">&quot;*** cpo.retrafo ***</span><span class="ch">\n</span><span class="st">&quot;</span>)
      <span class="kw">cat</span>(<span class="st">&quot;Control:</span><span class="ch">\n</span><span class="st">&quot;</span>)
      <span class="kw">print</span>(ctrl)
      <span class="kw">cat</span>(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">data:</span><span class="ch">\n</span><span class="st">&quot;</span>)
      <span class="kw">print</span>(data)  <span class="co"># 'data' is deleted: NULL</span>
      <span class="kw">cat</span>(<span class="st">&quot;target:</span><span class="ch">\n</span><span class="st">&quot;</span>)
      <span class="kw">print</span>(target)  <span class="co"># 'target' is deleted: NULL</span>
      greatest =<span class="st"> </span><span class="kw">order</span>(-ctrl)  <span class="co"># columns, ordered greatest to smallest var</span>
      x[greatest[<span class="kw">seq_len</span>(n.col)]]
    }
  })

cpo =<span class="st"> </span><span class="kw">xmpFilterVarFunc</span>(<span class="dv">2</span>)</code></pre></div>
<p>(Note that the function heads are optional.)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">trafd =</span> <span class="kw">head</span>(iris) %&gt;&gt;%<span class="st"> </span>cpo)
<span class="co">#&gt; *** cpo.train ***</span>
<span class="co">#&gt; Warning in checkFunctionReturn(cpo.retrafo, &quot;data&quot;, &quot;cpo.retrafo&quot;, &quot;cpo.train&quot;): The function given as cpo.retrafo references a data and a target variable.</span>
<span class="co">#&gt; Beware that the 'data' and 'target' variable as given as an argument to the surrounding function</span>
<span class="co">#&gt; will not be accessible when cpo.retrafo is called.</span>
<span class="co">#&gt; If you still need to access this data, copy it to a variable with a different name.</span>
<span class="co">#&gt; If this warning is a false positive and you assign the 'data' variable properly, you can avoid</span>
<span class="co">#&gt; this warning by renaming the 'data' variable.</span>
<span class="co">#&gt; *** cpo.retrafo ***</span>
<span class="co">#&gt; Control:</span>
<span class="co">#&gt; Sepal.Length  Sepal.Width Petal.Length  Petal.Width </span>
<span class="co">#&gt;  0.083000000  0.117666667  0.019000000  0.006666667 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; data:</span>
<span class="co">#&gt; NULL</span>
<span class="co">#&gt; target:</span>
<span class="co">#&gt; NULL</span>
<span class="co">#&gt;   Species Sepal.Width Sepal.Length</span>
<span class="co">#&gt; 1  setosa         3.5          5.1</span>
<span class="co">#&gt; 2  setosa         3.0          4.9</span>
<span class="co">#&gt; 3  setosa         3.2          4.7</span>
<span class="co">#&gt; 4  setosa         3.1          4.6</span>
<span class="co">#&gt; 5  setosa         3.6          5.0</span>
<span class="co">#&gt; 6  setosa         3.9          5.4</span></code></pre></div>
<p>The <code>CPOTrained</code> state for a functional <code>CPO</code> is the <em>environment</em> of the retrafo function. It contains the “<code>ctrl</code>” variable defined during training, the parameters given to <code>cpo.train</code>, and the <code>cpo.retrafo</code> function itself. Note that <code>data</code> and <code>target</code> are deleted and replaced by different values.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getCPOTrainedState</span>(<span class="kw">retrafo</span>(trafd))
<span class="co">#&gt; $ctrl</span>
<span class="co">#&gt; Sepal.Length  Sepal.Width Petal.Length  Petal.Width </span>
<span class="co">#&gt;  0.083000000  0.117666667  0.019000000  0.006666667 </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $data</span>
<span class="co">#&gt; $data$shapeinfo.input</span>
<span class="co">#&gt; &lt;ShapeInfo (input) Sepal.Length: num, Sepal.Width: num, Petal.Length: num, Petal.Width: num, Species: fac&gt;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $data$shapeinfo.output</span>
<span class="co">#&gt; &lt;ShapeInfo (output)&gt;:</span>
<span class="co">#&gt; numeric:</span>
<span class="co">#&gt; &lt;ShapeInfo Sepal.Width: num, Sepal.Length: num&gt;</span>
<span class="co">#&gt; factor:</span>
<span class="co">#&gt; &lt;ShapeInfo Species: fac&gt;</span>
<span class="co">#&gt; other:</span>
<span class="co">#&gt; &lt;ShapeInfo (empty)&gt;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $target</span>
<span class="co">#&gt; NULL</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $n.col</span>
<span class="co">#&gt; [1] 2</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $cpo.retrafo</span>
<span class="co">#&gt; function (x) </span>
<span class="co">#&gt; {</span>
<span class="co">#&gt;     cat(&quot;*** cpo.retrafo ***\n&quot;)</span>
<span class="co">#&gt;     cat(&quot;Control:\n&quot;)</span>
<span class="co">#&gt;     print(ctrl)</span>
<span class="co">#&gt;     cat(&quot;\ndata:\n&quot;)</span>
<span class="co">#&gt;     print(data)</span>
<span class="co">#&gt;     cat(&quot;target:\n&quot;)</span>
<span class="co">#&gt;     print(target)</span>
<span class="co">#&gt;     greatest = order(-ctrl)</span>
<span class="co">#&gt;     x[greatest[seq_len(n.col)]]</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;environment: 0xb54cfc8&gt;</span></code></pre></div>
</div>
<div id="stateless-cpo" class="section level4">
<h4>Stateless CPO</h4>
<p>“Stateless” <code>CPO</code>s are <code>CPO</code>s that perform the same action during transformation of training and prediction data, independent from information during training. An example would be a <code>CPO</code> that converts all its columns to <code>numeric</code> columns. When a FOCPO does not need a state, the <code>cpo.train</code> parameter of <code>makeCPO()</code> can be set to <code>NULL</code>. The <code>cpo.retrafo</code> function then has no <code>control</code> paramter and instead only a <code>data</code> and any <code>par.set</code> parameter. The <code>as.numeric</code>-<code>CPO</code> could be written as the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xmpAsNum =<span class="st"> </span><span class="kw">makeCPO</span>(<span class="st">&quot;asnum&quot;</span>,  <span class="co"># nolint</span>
  <span class="dt">cpo.train =</span> <span class="ot">NULL</span>,
  <span class="dt">cpo.retrafo =</span> function(data) {
    <span class="kw">data.frame</span>(<span class="kw">lapply</span>(data, as.numeric))
  })

cpo =<span class="st"> </span><span class="kw">xmpAsNum</span>()</code></pre></div>
<p>(Note that the function head is optional.)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">trafd =</span> <span class="kw">head</span>(iris) %&gt;&gt;%<span class="st"> </span>cpo)
<span class="co">#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width Species</span>
<span class="co">#&gt; 1          5.1         3.5          1.4         0.2       1</span>
<span class="co">#&gt; 2          4.9         3.0          1.4         0.2       1</span>
<span class="co">#&gt; 3          4.7         3.2          1.3         0.2       1</span>
<span class="co">#&gt; 4          4.6         3.1          1.5         0.2       1</span>
<span class="co">#&gt; 5          5.0         3.6          1.4         0.2       1</span>
<span class="co">#&gt; 6          5.4         3.9          1.7         0.4       1</span></code></pre></div>
<p>The “state” of the <code>CPOTrained</code> object thus created only contains information about the incoming <em>data shape</em>, to make sure that the <code>CPOTrained</code> object is only used on conforming data (as doing otherwise would indicate a bug).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getCPOTrainedState</span>(<span class="kw">retrafo</span>(trafd))
<span class="co">#&gt; $data</span>
<span class="co">#&gt; $data$shapeinfo.input</span>
<span class="co">#&gt; &lt;ShapeInfo (input) Sepal.Length: num, Sepal.Width: num, Petal.Length: num, Petal.Width: num, Species: fac&gt;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $data$shapeinfo.output</span>
<span class="co">#&gt; &lt;ShapeInfo (output) Sepal.Length: num, Sepal.Width: num, Petal.Length: num, Petal.Width: num, Species: num&gt;</span></code></pre></div>
</div>
</div>
<div id="makecpoextendedtrafo" class="section level3">
<h3><code>makeCPOExtendedTrafo()</code></h3>
<p>Sometimes it is advantageous to have the training operation return the transformed data right away. PCA, for example, returns the rotation matrix <em>and</em> the transformed data; it would be a waste of time to only return the rotation matrix in a <code>cpo.train</code> function and apply it on the training data in <code>cpo.retrafo</code>. The <code>makeCPOExtendedTrafo()</code> function works very much like <code>makeCPO()</code>, with the difference that it has a <code>cpo.trafo</code> instead of a <code>cpo.train</code> function parameter. The <code>cpo.trafo</code> takes the same parameters as <code>cpo.train</code>, but returns the <em>transformed data</em> instead of a control object. The control object needs to be created <em>additionally</em>, as a variable by the <code>cpo.trafo</code> function. The <code>CPO</code> framework takes the value of a variable named <code>control</code> inside the <code>cpo.trafo</code> function and gives it to the <code>cpo.retrafo</code> function.</p>
<p>The following is a simplified version of the <code>cpoPca</code> <code>CPO</code>, which does not scale or center the data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xmpPca =<span class="st"> </span><span class="kw">makeCPOExtendedTrafo</span>(<span class="st">&quot;simple.pca&quot;</span>,  <span class="co"># nolint</span>
  <span class="kw">pSS</span>(n.col:<span class="st"> </span>integer[<span class="dv">0</span>, ]),
  <span class="dt">dataformat =</span> <span class="st">&quot;numeric&quot;</span>,
  <span class="dt">cpo.trafo =</span> function(data, target, n.col) {
    <span class="kw">cat</span>(<span class="st">&quot;*** cpo.trafo ***</span><span class="ch">\n</span><span class="st">&quot;</span>)
    pcr =<span class="st"> </span><span class="kw">prcomp</span>(<span class="kw">as.matrix</span>(data), <span class="dt">center =</span> <span class="ot">FALSE</span>, <span class="dt">scale. =</span> <span class="ot">FALSE</span>, <span class="dt">rank =</span> n.col)
    <span class="co"># save the rotation matrix as 'control' variable</span>
    control =<span class="st"> </span>pcr$rotation
    pcr$x
  },
  <span class="dt">cpo.retrafo =</span> function(data, control, n.col) {
    <span class="kw">cat</span>(<span class="st">&quot;*** cpo.retrafo ***</span><span class="ch">\n</span><span class="st">&quot;</span>)
    <span class="co"># rotate the data by the rotation matrix</span>
    <span class="kw">as.matrix</span>(data) %*%<span class="st"> </span>control
  })

cpo =<span class="st"> </span><span class="kw">xmpPca</span>(<span class="dv">2</span>)</code></pre></div>
<p>When this <code>CPO</code> is applied to data, only the <code>cpo.trafo</code> function is called.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">trafd =</span> <span class="kw">head</span>(iris) %&gt;&gt;%<span class="st"> </span>cpo)
<span class="co">#&gt; *** cpo.trafo ***</span>
<span class="co">#&gt;   Species       PC1           PC2</span>
<span class="co">#&gt; 1  setosa -6.344251  3.699099e-05</span>
<span class="co">#&gt; 2  setosa -5.909522 -2.939100e-01</span>
<span class="co">#&gt; 3  setosa -5.835572 -1.780612e-02</span>
<span class="co">#&gt; 4  setosa -5.747518 -5.192580e-02</span>
<span class="co">#&gt; 5  setosa -6.319018  1.359890e-01</span>
<span class="co">#&gt; 6  setosa -6.882318  1.859359e-01</span></code></pre></div>
<p>When the retrafo <code>CPOTrained</code> is used, the <code>cpo.retrafo</code> function is called, making use of the rotation matrix.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tail</span>(iris) %&gt;&gt;%<span class="st"> </span><span class="kw">retrafo</span>(trafd)
<span class="co">#&gt; *** cpo.retrafo ***</span>
<span class="co">#&gt;       Species       PC1        PC2</span>
<span class="co">#&gt; 145 virginica -8.614333 -0.7582980</span>
<span class="co">#&gt; 146 virginica -8.324575 -1.0203095</span>
<span class="co">#&gt; 147 virginica -7.667317 -1.2766319</span>
<span class="co">#&gt; 148 virginica -8.152840 -0.9708329</span>
<span class="co">#&gt; 149 virginica -8.190484 -0.4297855</span>
<span class="co">#&gt; 150 virginica -7.640937 -0.6764400</span></code></pre></div>
<p>The rotation matrix can be inspected using <code>getCPOTrainedState</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getCPOTrainedState</span>(<span class="kw">retrafo</span>(trafd))
<span class="co">#&gt; $n.col</span>
<span class="co">#&gt; [1] 2</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $control</span>
<span class="co">#&gt;                     PC1         PC2</span>
<span class="co">#&gt; Sepal.Length -0.8012756 -0.55116118</span>
<span class="co">#&gt; Sepal.Width  -0.5489467  0.80835852</span>
<span class="co">#&gt; Petal.Length -0.2348418 -0.04199971</span>
<span class="co">#&gt; Petal.Width  -0.0382656  0.20251883</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $data</span>
<span class="co">#&gt; $data$shapeinfo.input</span>
<span class="co">#&gt; &lt;ShapeInfo (input) Sepal.Length: num, Sepal.Width: num, Petal.Length: num, Petal.Width: num, Species: fac&gt;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $data$shapeinfo.output</span>
<span class="co">#&gt; &lt;ShapeInfo (output)&gt;:</span>
<span class="co">#&gt; numeric:</span>
<span class="co">#&gt; &lt;ShapeInfo PC1: num, PC2: num&gt;</span>
<span class="co">#&gt; factor:</span>
<span class="co">#&gt; &lt;ShapeInfo Species: fac&gt;</span>
<span class="co">#&gt; other:</span>
<span class="co">#&gt; &lt;ShapeInfo (empty)&gt;</span></code></pre></div>
<div id="functional-cpo-1" class="section level4">
<h4>Functional CPO</h4>
<p>As with <code>makeCPO()</code>, <code>makeCPOExtendedTrafo()</code> makes it possible to define functional <code>CPO</code>s. Instead of <em>returning</em> a <code>cpo.retrafo</code> function, the <code>cpo.retrafo</code> function needs to be <em>defined</em> as a variable, instead of a “<code>control</code>” variable. Like in <code>makeCPO()</code>, the <code>cpo.retrafo</code> parameter of <code>makeCPOExtendedTrafo()</code> must then be <code>NULL</code>. The PCA example above could thus also be written as</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">xmpPcaFunc =<span class="st"> </span><span class="kw">makeCPOExtendedTrafo</span>(<span class="st">&quot;simple.pca.func&quot;</span>,  <span class="co"># nolint</span>
  <span class="kw">pSS</span>(n.col:<span class="st"> </span>integer[<span class="dv">0</span>, ]),
  <span class="dt">dataformat =</span> <span class="st">&quot;numeric&quot;</span>,
  <span class="dt">cpo.retrafo =</span> <span class="ot">NULL</span>,
  <span class="dt">cpo.trafo =</span> function(data, target, n.col) {
    <span class="kw">cat</span>(<span class="st">&quot;*** cpo.trafo ***</span><span class="ch">\n</span><span class="st">&quot;</span>)
    pcr =<span class="st"> </span><span class="kw">prcomp</span>(<span class="kw">as.matrix</span>(data), <span class="dt">center =</span> <span class="ot">FALSE</span>, <span class="dt">scale. =</span> <span class="ot">FALSE</span>, <span class="dt">rank =</span> n.col)
    <span class="co"># save the rotation matrix as 'control' variable</span>
    cpo.retrafo =<span class="st"> </span>function(data) {
      <span class="kw">cat</span>(<span class="st">&quot;*** cpo.retrafo ***</span><span class="ch">\n</span><span class="st">&quot;</span>)
      <span class="co"># rotate the data by the rotation matrix</span>
      <span class="kw">as.matrix</span>(data) %*%<span class="st"> </span>pcr$rotation
    }
    pcr$x
  })

cpo =<span class="st"> </span><span class="kw">xmpPcaFunc</span>(<span class="dv">2</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="dt">trafd =</span> <span class="kw">head</span>(iris) %&gt;&gt;%<span class="st"> </span>cpo)
<span class="co">#&gt; *** cpo.trafo ***</span>
<span class="co">#&gt;   Species       PC1           PC2</span>
<span class="co">#&gt; 1  setosa -6.344251  3.699099e-05</span>
<span class="co">#&gt; 2  setosa -5.909522 -2.939100e-01</span>
<span class="co">#&gt; 3  setosa -5.835572 -1.780612e-02</span>
<span class="co">#&gt; 4  setosa -5.747518 -5.192580e-02</span>
<span class="co">#&gt; 5  setosa -6.319018  1.359890e-01</span>
<span class="co">#&gt; 6  setosa -6.882318  1.859359e-01</span></code></pre></div>
<p>This also serves as an example of the disadvantages of a functional <code>CPO</code>: Since the <code>CPO</code> state contains all the information contained in the <code>cpo.trafo</code> call (except the <code>data</code> and <code>target</code> variables), it may take up more memory than needed. For this <code>CPO</code>, the state contains the <code>pcr</code> variable which contains the transformed training data in its <code>$x</code> slot. If the training data is a very large dataset, this would result in <code>CPO</code> states that take up a lot of working memory.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getCPOTrainedState</span>(<span class="kw">retrafo</span>(trafd))$pcr$x
<span class="co">#&gt;         PC1           PC2</span>
<span class="co">#&gt; 1 -6.344251  3.699099e-05</span>
<span class="co">#&gt; 2 -5.909522 -2.939100e-01</span>
<span class="co">#&gt; 3 -5.835572 -1.780612e-02</span>
<span class="co">#&gt; 4 -5.747518 -5.192580e-02</span>
<span class="co">#&gt; 5 -6.319018  1.359890e-01</span>
<span class="co">#&gt; 6 -6.882318  1.859359e-01</span></code></pre></div>
</div>
</div>
</div>
<div id="target-operation-cpos" class="section level2">
<h2>Target Operation CPOs</h2>
<p>TODO</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
