
##################################
### Printing                   ###
##################################

#' @title Print CPO objects.
#'
#' @description
#' Prints a simple representation of a \code{\link{CPOConstructor}},
#' \code{\link{CPO}} or \code{\link{CPOTrained}}. If
#' \code{verbose} is \code{TRUE}, more information about the given objects
#' will be given. For \code{\link{CPOConstructor}}, that is the trafo and retrafo
#' functions, for \code{\link{CPO}}, the individual constituents of a compound
#' CPO will be printed.
#'
#' @param x [\code{\link{CPOConstructor}} | \code{\link{CPO}} | \code{\link{CPOTrained}}]\cr
#'   The \code{\link{CPOConstructor}} to print.
#' @param verbose [\code{logical(1)}]\cr
#'   Whether to print further information. Default is \code{FALSE}.
#' @return [\code{invisible(NULL)}].
#' @family CPOConstructor related
#' @export
print.CPOConstructor = function(x, verbose = FALSE, ...) {
  assertFlag(verbose)
  args = dropNamed(formals(x), environment(x)$reserved.params)
  argvals = sapply(args, function(y) if (identical(y, substitute())) "" else paste(" =", convertToShortString(y)))
  argstring = paste(names(args), argvals, collapse = ", ", sep = "")
  catf("<<CPO %s(%s)>>", getCPOName(x), argstring)
  if (verbose) {
    type.extended = environment(x)$cpo.type.extended
    tf = environment(x)$trafo.funs
    allfuns = c("trafo", "retrafo", "train.invert", "invert")

    relfuns = switch(type.extended,
      feature = allfuns[1:2], target = allfuns, retrafoless = allfuns[1],
      feature.extended = allfuns[1:2], target.extended = allfuns[-3])
    relfunlist = lapply(relfuns, function(x) tf[[paste0(x, ".orig")]])
    if (type.extended %in% c("trafo", "retrafo")) {
      name(relfunlist)[1] = "train"
    }
    for (funname in names(relfunlist)) {
      fun = relfunlist[[funname]]
      if (!is.null(fun)) {
        catf("\ncpo.%s:", funname)
        print(fun)
      }
    }
  }
}

# verbose print function for CPOs:
# calls nonverbose-print in return for all included primitive CPOs.
# @param x [CPO] the CPO to print
vprint = function(x) {
  chain = as.list(x)
  catf("Trafo chain of %d cpos:", length(chain))
  is.first = TRUE
  for (cpo in chain) {
    if (!is.first) {
      cat("  ====>\n")
    }
    is.first = FALSE
    print(cpo)
    ot = getCPOOperatingType(cpo)
    catf("Operating: %s", ot, newline = FALSE)
    if (ot == "target") {
      if (cpo$constant.invert) {
        cat(" [constant invert]")
      }
      catf("\nConversion: %s -> %s", cpo$convertfrom, cpo$convertto)
      pt = getCPOPredictType(cpo)
      catf("Predict type maping:\n%s", collapse(paste(names(pt), pt, sep = " -> "), sep = "\n"))
    } else {
      cat("\n")
    }
    cat("ParamSet:\n")
    print(getParamSet(cpo))
  }
}

#' @rdname print.CPOConstructor
#' @export
print.CPO = function(x, verbose = FALSE, ...) {
  if (verbose) {
    return(vprint(x))
  }
  isprim = "CPOPrimitive" %in% class(x)
  pv = if (isprim) getBareHyperPars(x) else getHyperPars(x)
  argstring = paste(names(pv), sapply(pv, convertToShortString), sep = " = ", collapse = ", ")
  template = ifelse("CPOPrimitive" %in% class(x), "%s(%s)", "(%s)(%s)")
  catf(template, x$debug.name, argstring, newline = FALSE)
  if (isprim && length({unexport = x$unexported.pars})) {
      catf("[not exp'd: %s]", paste(names(unexport), sapply(unexport, convertToShortString), sep = " = ", collapse = ", "), newline = FALSE)
  }
  if (isprim && length({affect = getCPOAffect(x)})) {
    catf(" [%s]", paste(names(affect), sapply(affect, convertToShortString), sep = " = ", collapse = ", "))
  } else {
    cat("\n")
  }
}

#' @rdname print.CPOConstructor
#' @family retrafo related
#' @family inverter related
#' @export
print.CPOTrained = function(x, ...) {
  first = TRUE
  object.type = getCPOClass(x)
  invcap = getCPOTrainedCapability(x)
  pt = names(getCPOPredictType(x))
  caps = names(Filter(function(x) x > 0, invcap))
  catf("CPO %s chain", collapse(stri_trans_totitle(caps), sep = " / "), newline = FALSE)
  if (invcap["invert"] > 0) {
    catf("(able to predict '%s')", collapse(pt, sep = "', '"))
  } else {
    cat("\n")
  }
  reverse = invcap["retrafo"] < 1
  plist = as.list(x)
  if (reverse) {
    plist = rev(plist)
  }
  for (primitive in plist) {
    if (!first) {
      cat("=>")
    }
    first = FALSE
    pv = getHyperPars(primitive)
    argstring = paste(names(pv), sapply(pv, convertToShortString), sep = " = ", collapse = ", ")
    pcap = getCPOTrainedCapability(primitive)
    if (pcap["invert"] > 0) {
      fromto = c(primitive$convertfrom, primitive$convertto)
      if (reverse) {
        fromto = rev(fromto)
      }
      convstring = paste0("{conv:", collapse(fromto, "->"), "}")
    } else {
      convstring = ""
    }
    if (pcap["retrafo"] < 1) {
      classname = "INVERTER"
    } else {
      classname = "RETRAFO"
    }
    catf("[%s %s(%s)%s]", classname, getCPOName(primitive), argstring, convstring, newline = FALSE)
  }
  cat("\n")
}

# helper function for retrafo / inverter 'element's
# The user shouldn't see these too often
#' @export
print.RetrafoElement = function(x, ...) {
  if (!is.null(x$prev.retrafo.elt)) {
      x$prev.retrafo.elt = paste0("<More ", class(x$prev.retrafo.elt), ">")
  }
  print(c(x))
}
#' @export
print.InverterElement = print.RetrafoElement


# ShapeInfo printing

# helper function for printing single shapeinfo row
# @param x [ShapeInfo] the ShapeInfo to print
catSI = function(x) {
  if (length(x$colnames)) {
    cat(collapse(sprintf("%s: %s", x$colnames, substr(x$coltypes, 1, 3)), sep = ", "))
  } else {
    cat("(empty)")
  }
}

# pretty-print shapeinfo; mostly useful for debugging, the user
# hardly ever gets to see this, except possibly when inspecting
# retrafo state.
#' @export
print.OutputShapeInfo = function(x, ...) {
  cat("<ShapeInfo (output)")
  if (all(c("colnames", "coltypes") %in% names(x))) {
    cat(" ")
    catSI(x)
    cat(">\n")
  } else {
    cat(">:\n")
    for (s in names(x)) {
      cat(s, ":\n", sep = "")
      print(x[[s]])
    }
  }
}

#' @export
print.InputShapeInfo = function(x, ...) {
  cat("<ShapeInfo (input) ")
  catSI(x)
  cat(">\n")
}

#' @export
print.ShapeInfo = function(x, ...) {
  cat("<ShapeInfo ")
  catSI(x)
  cat(">\n")
}

#' @export
print.ListCPO = function(x, ...) {
  printHead(as.data.frame(dropNamed(x, drop = "description")), ...)
}
