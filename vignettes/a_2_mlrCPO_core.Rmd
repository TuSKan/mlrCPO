---
title: "mlrCPO Core"
author: "Martin Binder"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{2. mlrCPO Core}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r, eval = TRUE, child = 'toc/vignettetoc.Rmd'}
```

```{r, eval = TRUE, echo = FALSE, results = 'asis'}
printToc(4)
```

## Introduction

This vignette is supposed to be a short reference of the primitives and tools supplied by the `mlrCPO` package.

## Lifecycle of a CPO

**CPO**s are first-class objects in R that represent data manipulation. They can be combined to form networks of operation, they can be attached to `mlr` `Learner`s, and they have tunable Hyperparameters that influence their behaviour. `CPO`s go through a lifecycle from construction to `CPO` to a `CPOTrained` "retrafo" or "inverter" object. The different stages of a `CPO` related object can be distinguished using **`getCPOClass()`**, which takes one of five values:

```{r}
getCPOClass(cpoPca)
getCPOClass(cpoPca())
getCPOClass(pid.task %>|% cpoPca())
getCPOClass(inverter(bh.task %>>% cpoLogTrafoRegr()))
getCPOClass(NULLCPO)
```

## CPOConstructor

`CPO`s are created using **`CPOConstructor`**s. These are R functions with a print function and many parameters in common.

```{r}
print(cpoAsNumeric)  # example CPOConstructor
print(cpoAsNumeric, verbose = TRUE)  # alternative: !cpoAsNumeric
class(cpoAsNumeric)
getCPOName(cpoPca)  # same as getCPOName() of the *constructed* CPO
getCPOClass(cpoPca)
```

The function parameters of a `CPOConstructor`

* set the `CPO` Hyperparameters
* set the `CPO` `id` (default to the `CPO`'s `name`)
* resetrict the data columns a CPO operates on (`affect.*` parameters)
* control which of the `CPO`'s hyperparameters are "exported", i.e. can late be manipulated using `setHyperPars()`.

```{r}
names(formals(cpoPca))
```

### CPO

```{r}
(cpo = cpoScale()) # construct CPO with default Hyperparameter values
print(cpo, verbose = TRUE)  # detailed printing. Alternative: !cpo
class(cpo)  # CPOs that are not compound are "CPOPrimitive"
getCPOClass(cpo)
```

### Functions that work on CPOs

The inner "state" of a `CPO` can be inspected and manipulated using various getters and setters.

```{r}
getParamSet(cpo)
getHyperPars(cpo)
setHyperPars(cpo, scale.center = FALSE)
getCPOId(cpo)
setCPOId(cpo, "MYID")
getCPOName(cpo)
getCPOAffect(cpo)  # empty, since no affect set
getCPOAffect(cpoPca(affect.pattern = "Width$"))
getCPOConstructor(cpo)  # the constructor used to create the CPO
getCPOProperties(cpo)  # see properties explanation below
getCPOPredictType(cpo)
getCPOOperatingType(cpo)  # Operating on feature, target, retrafoless?
```

Compare the predict type and operating type of a TOCPO or ROCPO:

```{r}
getCPOPredictType(cpoResponseFromSE())
getCPOOperatingType(cpoResponseFromSE())
getCPOOperatingType(cpoSample())
```

### Exporting Parameters

Sometimes when using many CPOs, their hyperparameters may get messy. `mlrCPO` enables the user to control which hyperparameter get exported. The parameter "export" can be one of `"export.default"`, `"export.set"`, `"export.unset"`, `"export.default.set"`, `"export.default.unset"`, `"export.all"`, `"export.none"`. "all" and "none" do what one expects; "default" exports the "recommended" parameters; "set" and "unset" export the values that have not been set, or only the values that were set (and are not left as default). "default.set" and "default.unset" work as "set" and "unset", but restricted to the default exported parameters.

```{r}
!cpoScale()
```
```{r}
!cpoScale(export = "export.none")
```
```{r}
!cpoScale(scale = FALSE, export = "export.unset")
```

### CPO Application using `%>>%` or `applyCPO`
`CPO`s can be applied to `data.frame` and `Task` objects.

```{r}
head(iris) %>>% cpoPca()
task = applyCPO(cpoPca(), iris.task)
head(getTaskData(task))
```

### CPO Composition using `%>>%` or `composeCPO`
`CPO` composition results in a new CPO which mostly behaves like a primitive CPO. Exceptions are:

* Compound CPOs have no `id`
* Affect of compound CPOs cannot be retrieved

```{r}
scale1 = cpoScale()
scale2 = cpoScale()
```
```{r, error = TRUE}
scale1 %>>% scale2  # error! parameters 'center' and 'scale' occur in both
```
```{r}
compound = setCPOId(scale1, "scale1") %>>% setCPOId(scale2, "scale2")
composeCPO(setCPOId(scale1, "scale1"), setCPOId(scale2, "scale2"))  # same
class(compound)
!compound
getCPOName(compound)
getHyperPars(compound)
setHyperPars(compound, scale1.center = TRUE, scale2.center = FALSE)
```
```{r, error = TRUE}
getCPOId(compound)  # error: no ID for compound CPOs
getCPOAffect(compound)  # error: no affect for compound CPOs
```

`getCPOOperatingType()` always considers the operating type of the whole `CPO` chain and may return multiple values:
```{r}
getCPOOperatingType(NULLCPO)
getCPOOperatingType(cpoScale())
getCPOOperatingType(cpoScale() %>>% cpoLogTrafoRegr() %>>% cpoSample())
```

### Compound CPO decomposition, CPO chaining

```{r}
as.list(compound)
pipeCPO(as.list(compound))  # chainCPO: (list of CPO) -> CPO
pipeCPO(list())
```

## CPOLearner: CPO - Learner attachment using `%>>%` or `attachCPO`

```{r}
lrn = makeLearner("classif.logreg")
(cpolrn = cpo %>>% lrn)  # the new learner has the CPO hyperparameters
attachCPO(compound, lrn)  # attaching compound CPO
```
The new object is a `CPOLearner`, which performs the operation given by the `CPO` before trainign the `Learner`.
```{r}
class(lrn)
```

The work performed by a `CPOLearner` can also be performed manually:
```{r}
lrn = cpoLogTrafoRegr() %>>% makeLearner("regr.lm")
model = train(lrn, subsetTask(bh.task, 1:300))
predict(model, subsetTask(bh.task, 301:500))
```
is equivalent to
```{r}
trafo = subsetTask(bh.task, 1:300) %>>% cpoLogTrafoRegr()
model = train("regr.lm", trafo)

newdata = subsetTask(bh.task, 301:500) %>>% retrafo(trafo)
pred = predict(model, newdata)
invert(inverter(newdata), pred)
```

CPO learner decomposition
```{r}
getLearnerCPO(cpolrn)  # the CPO
getLearnerBare(cpolrn)  # the Learner
```

### CPOTrained

CPOs perform data-dependent operation. However, when this operation becomes part of a machine-learning process, the operation on predict-data must depend only on the training data. A `CPORetrafo` object represents the re-application of a trained CPO. A `CPOInverter` object represents the transformation of a prediction made on a transformed task back to the form of the original data.

```{r}
transformed = iris %>>% cpoScale()
head(transformed)
(ret = retrafo(transformed))
```

```{r}
head(getTaskTargets(bh.task))
transformed = bh.task %>>% cpoLogTrafoRegr()
head(getTaskTargets(transformed))
(inv = inverter(transformed))
head(invert(inv, getTaskTargets(transformed)))
```

#### Functions that work on CPOTrained

```{r}
# General methods that work on retrafo
getCPOName(ret)
getHyperPars(ret)
getCPOClass(ret)
getCPOClass(inv)
getCPOOperatingType(ret)  # Operating on feature, target, both?
getCPOOperatingType(inv)
getCPOPredictType(ret)
getCPOPredictType(inv)
```

A `CPOTrained` has information about whether it can be used as a `CPORetrafo` object (and be applied to new data using `%>>%`), or as a `CPOInverter` object (and used by `invert()`), or possibly both. This is given by `getCPOTrainedCapability()`, which returns a `1` if the object has an effect in the given role, `0` if the object has no effect (but can be used), or `-1` if the object can not be used in the role.
```{r}
getCPOTrainedCapability(ret)
getCPOTrainedCapability(inv)
getCPOTrainedCapability(NULLCPO)
```
Retrafos and inverters are stored as attributes:
```{r}
attributes(transformed)
```

#### CPOTrained Inspection
`CPOTrained` objects can be inspected using `getCPOTrainedState()`. The state contains the hyperparameters, the `control` object (CPO dependent data representing the data information needed to re-apply the operation), and information about the `Task` / `data.frame` layout used for training (column names, column types) in `data$shapeinfo.input` and `data$shapeinfo.output`.

The state can be manipulated and used to create new `CPOTrained`s, using `makeCPOTrainedFromState()`.

```{r}
(state = getCPOTrainedState(retrafo(iris %>>% cpoScale())))
state$control$center[1] = 1000  # will now subtract 1000 from the first column
new.retrafo = makeCPOTrainedFromState(cpoScale, state)
head(iris %>>% new.retrafo)
```

#### Application of CPORetrafo using `%>>%`, `applyCPO`, or `predict`

```{r}
transformed = iris %>>% cpoScale()
head(iris) %>>% retrafo(transformed)
```
Should in general give the same as `head(transformed)`, since the same data was used:
```{r}
head(transformed)
```
**`applyCPO()`** and **`predict()`** are synonyms of `%>>%` when used for `CPORetrafo` objects:
```{r, eval = FALSE}
applyCPO(retrafo(transformed), head(iris))
predict(retrafo(transformed), head(iris))
```

#### Retrafos are automatically chained when applying CPOs (!)
When executing `data %>>% CPO`, the result has an associated `CPORetrafo` and `CPOInverter` object. When applying another `CPO`, the `CPORetrafo` and `CPOInverter` will be chained automatically. This is to make `(data %>>% CPO1) %>>% CPO2` work the same as `data %>>% (CPO1 %>>% CPO2)`.

```{r}
data = head(iris) %>>% cpoPca()
retrafo(data)
data2 = data %>>% cpoScale()
```
`retrafo(data2)` is the same as `retrafo(data %>>% pca %>>% scale)`:
```{r}
retrafo(data2)
```
To interrupt this chain, set retrafo to `NULL` either explicitly, or using `clearRI()`.
```{r}
data = clearRI(data)
data2 = data %>>% cpoScale()
retrafo(data2)
```
this is equivalent to
```{r}
retrafo(data) = NULL
inverter(data) = NULL
data3 = data %>>% cpoScale()
retrafo(data3)
```

#### CPOTrained Composition, Decomposition, Chaining
Using `as.list` and `pipeCPO`, just like for `CPO`s.
```{r}
compound.retrafo = retrafo(head(iris) %>>% compound)
compound.retrafo
```
```{r}
(retrafolist = as.list(compound.retrafo))
```
```{r}
retrafolist[[1]] %>>% retrafolist[[2]]
pipeCPO(retrafolist)
```

## CPO Properties
CPOs contain information about the kind of data they can work with, and what kind of data they produce. `getCPOProperties` returns a list with the slots `handling`, `adding`, `needed`. `properties$handling` indicates the kind of data a CPO can handle, `properties$needed` indicates the kind of data it needs the data receiver (e.g. attached learner) to have, and `properties$adding` lists the properties it adds to a given learner. An example is `cpoDummyEncode()`, a CPO that converts factors to numerics: The receiving learner needs to handle numerics, so `properties$needed == "numerics"`, but it *adds* the ability to handle factors (since they are converted), so `properties$adding = c("factors", "ordered")`.

```{r}
getCPOProperties(cpoDummyEncode())
```

As a result, `cpoDummyEncode` endows a `Learner` with the ability to train on data with factor variables:
```{r, error = TRUE}
train("classif.geoDA", bc.task)  # gives an error
```
```{r}
train(cpoDummyEncode(reference.cat = TRUE) %>>% makeLearner("classif.geoDA"), bc.task)
```
```{r}
getLearnerProperties("classif.geoDA")
```
```{r}
getLearnerProperties(cpoDummyEncode(TRUE) %>>% makeLearner("classif.geoDA"))
```

